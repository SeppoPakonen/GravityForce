// Allegro 4 compatibility functions for mappyal.c

// Additional Allegro 4 functions needed by mappyal.c
int getpixel(BITMAP *bmp, int x, int y) {
    // Allegro 5 doesn't have direct pixel access like Allegro 4
    // This is a simplified implementation that returns white for now
    (void)bmp; (void)x; (void)y; // avoid unused parameter warnings
    return 0xFFFFFF; // Return white
}

void acquire_bitmap(BITMAP *bmp) {
    // In Allegro 5, manual bitmap locking is not required like Allegro 4
    // This is a no-op function for compatibility
    (void)bmp; // avoid unused parameter warning
}

void release_bitmap(BITMAP *bmp) {
    // In Allegro 5, manual bitmap locking is not required like Allegro 4
    // This is a no-op function for compatibility
    (void)bmp; // avoid unused parameter warning
}

void set_clip(BITMAP *bmp, int x1, int y1, int x2, int y2) {
    if (!bmp || !bmp->bitmap) return;
    
    // In Allegro 5, clipping is handled differently
    // Store the clip values in the BITMAP structure for compatibility
    bmp->cl = x1;
    bmp->ct = y1;
    bmp->cr = x2;
    bmp->cb = y2;
}

void masked_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height) {
    if (!source || !source->bitmap || !dest || !dest->bitmap) return;
    
    ALLEGRO_BITMAP *old_target = al_get_target_bitmap();
    al_set_target_bitmap(dest->bitmap);
    
    // Use Allegro 5's draw bitmap region with alpha channel handling
    al_draw_tinted_scaled_bitmap(
        source->bitmap, 
        al_map_rgba(255, 255, 255, 255), // white tint with full opacity
        source_x, 
        source_y, 
        width, 
        height,
        dest_x, 
        dest_y, 
        width, 
        height,
        0  // flags
    );
    
    al_set_target_bitmap(old_target);
}

void blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height) {
    if (!source || !source->bitmap || !dest || !dest->bitmap) return;
    
    ALLEGRO_BITMAP *old_target = al_get_target_bitmap();
    al_set_target_bitmap(dest->bitmap);
    
    // Use Allegro 5's draw bitmap region
    al_draw_bitmap_region(
        source->bitmap,
        source_x,
        source_y,
        width,
        height,
        dest_x,
        dest_y,
        0  // flags
    );
    
    al_set_target_bitmap(old_target);
}

void destroy_bitmap(BITMAP *bmp) {
    if (!bmp) return;
    
    if (bmp->bitmap) {
        al_destroy_bitmap(bmp->bitmap);
    }
    delete bmp;
}

int bitmap_color_depth(BITMAP *bmp) {
    if (!bmp || !bmp->bitmap) return 0;
    
    // Allegro 5 doesn't provide color depth directly from bitmap
    // Return a default value
    return 32; // Assume 32-bit color depth
}

BITMAP *create_bitmap(int width, int height) {
    ALLEGRO_BITMAP *al_bitmap = al_create_bitmap(width, height);
    if (!al_bitmap) {
        return nullptr;
    }
    
    BITMAP *bmp = new BITMAP;
    bmp->bitmap = al_bitmap;
    bmp->w = al_get_bitmap_width(al_bitmap);
    bmp->h = al_get_bitmap_height(al_bitmap);
    
    // Initialize the line member for Allegro 4 compatibility
    // This is a temporary workaround to satisfy the compiler
    // In a real implementation, this would need to be properly initialized
    bmp->line = nullptr;
    
    // Initialize the clip members
    bmp->cl = 0;
    bmp->ct = 0;
    bmp->cr = width;
    bmp->cb = height;
    
    return bmp;
}

BITMAP *create_video_bitmap(int width, int height) {
    // In Allegro 5, we don't distinguish between video and system bitmaps like Allegro 4
    // Create a standard bitmap which should work for the purpose
    return create_bitmap(width, height);
}

int is_video_bitmap(BITMAP *bmp) {
    if (!bmp || !bmp->bitmap) return 0;
    
    // In Allegro 5, we don't have the same video/system bitmap distinction
    // Return 0 (false) as default for compatibility
    return 0;
}

void set_palette(const PALETTE pal) {
    // In Allegro 5, palette handling is different
    // For now, we'll just convert to ALLEGRO_COLOR array and set
    (void)pal; // unused parameter warning
    // TODO: Implement proper palette functionality if needed
}

void pack_fclose(PACKFILE *f) {
    if (!f) return;
    
    if (f->file) {
        al_fclose(f->file);
    }
    delete f;
}

int pack_fread(void *p, int size, PACKFILE *f) {
    if (!p || !f || !f->file) return 0;
    
    size_t result = al_fread(f->file, p, size);
    return result;
}

PACKFILE *pack_fopen(const char *filename, const char *mode) {
    // Map Allegro 4 packfile modes to Allegro 5 file modes
    ALLEGRO_FILE *al_file = al_fopen(filename, mode);
    if (!al_file) {
        return nullptr;
    }
    
    PACKFILE *pf = new PACKFILE;
    pf->file = al_file;
    return pf;
}

// Global variables
int gfx_capabilities = 0; // Initialize as no hardware acceleration

// End of file